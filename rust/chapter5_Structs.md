# Struct

여러가지의 관계있는 값들을 이름붙이고 모아 의미있는 그룹으로 만드는 Custom 데이터 타입.
Enum 과 함께 새로운 타입을 만드는 빌딩블록이며, 이렇게 새로운 타입을 만들줄 알아야 Rust 의 컴파일 타임 타입 체킹의 이익을 제대로 누릴 수 있다.

- tuple 과 유사하지만, 각 필드에 이름을 붙이기 때문에 순서에 신경쓰지 않아도 된다는 장점이 있다.
- struct 의 필드 하나만 mutable 하게 바꿀 순 없고, 전체 struct 를 `mut` 키워드로 mutable 하게 바꿀 수 있다.

# Method Syntax

- `impl` 키워드 사용
- 첫번째 인자는 항상 `self` 로, 현 메서드가 호출되고 있는 struct 의 인스턴스를 가리킨다.
- `self` 는 자기자신의 타입을 가지는 게 명확하기에 타입을 명시하지 않는다.
- 메서드는 `self` 의 소유권을 가져오거나, immutably 빌려오거나, mutably 빌려올 수 있다.
- 기존 소유권 개념과 동일하게, 인스턴스 데이터를 조회하는 것만이 목적이면 `&self` 로 가져오고, `&mut self` 로 인스턴스에 변화를 줄 수도 있다. 소유권을 아예 가져와버리는 건 매우 희귀한데, 아예 self 를 바꿔버린다거나 메서드 호출 후에 인스턴스를 사용불가능하게 만든다거나 하는 특별한 상황에만 사용한다.
- `C++` 등에서는 포인터에서 메서드를 호출할 때는 `.` 대신 `->` 를 사용하곤 한다. 예를 들어 `object` 가 포인터라면 `object->something()` 는 `(*object).something()` 와 거의 동일하다. 러스트는 _automatic referencing and dereferencing_ 이라는 기능이 있어서, 메서드의 `self` 타입에 맞게 객체를 조절한다. 즉 메서드 인자타입을 통해 소유권 상황이 어떤지 명확하게 한다.
- `self` 를 받지 않는 `impl` 내 함수를 정의할 수도 있다. 이런 함수를 _associated functions_ 라고 하는데, 이건 메서드는 아니고, 생성자(constructor)에서 인스턴스를 마는 데 많이 이용된다. 이런 관련 함수들을 호출할 때는 `::` 를 사용한다.
- struct 는 여러 `impl` 블럭을 가질 수 있다. 그럴 필요는 잘 없지만, 제네릭 타입과 traits 를 다룰 때 사용된다.
