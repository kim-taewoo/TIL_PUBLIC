## 클로저

### 클로저를 통한 캡슐화

클로저 덕분에 JS에서는 객체지향 프로그래밍, 즉 변수 또는 함수를 private 으로 활용할 수 있습니다.

클로저는 일종의 보호막이라 할 수 있습니다.

해당 함수가 존재하는 하는 동안 그 함수의 유효 범위에 있는 변수와 함수를 가비지 컬렉션으로부터 보호받기 때문이죠.

즉, 클로저는 변수의 유효범위를 제한하려는 용도로 사용할 수 있습니다. ( 캡슐화가 가능 )
이를 미루어 보아 클로저는 단순히 생성 시점 유효 범위의 환경을 순간 포착하는 것 뿐만 아니라,

외부에는 노출시키지 않으면서 선언 당시 유효 범위의 접근을 가능하게 하고 상태를 수정할 수 있게 해주는 **정보 은닉 수단**으로 활용 할 수도 있습니다.

### 클로저로 인해 발생할 수 있는 문제

**비동기**로 동작하는 함수를 사용하는 함수 내에서 반복문을 작성할 때, 클로저로 인해 문제가 발생할 수 있습니다.

```javascript
function count() {
    for (var i = 1; i < 10; i++) {
        setTimeout(function(){
            console.log(i);
        }, 1000);
    }
}

count();
// 10 을 9 번 출력해버림
```

이유는 반복문을 수행할 때 클로저에서 같은 변수를 공유하고 있기 때문입니다.

이에 대한 해결책으로는 두 가지가 있습니다.

해결책1: 즉시 실행함수
해결책2: 블록 스코프 let 사용

1. 일급 객체 ( First Class Obejct )

대부분의 스크립트 언어에서 객체는 일급 객체이며, 함수도 객체입니다.


## 일급객체
일급 객체란 다음의 조건을 만족하는 객체를 의미합니다.

1. 변수나 데이터 구조안에 담을 수 있다.
1. 파라미터로 전달 할 수 있다.
1. 반환 값(return value)으로 사용할 수 있다.
1. 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
1. 동적으로 프로퍼티 할당이 가능하다.


## THIS
위의 내용을 정리하면 this가 생성되는 경우는 다음과 같습니다.

- 객체가 메서드를 호출할 경우, 메서드를 호출한 객체가 this입니다.
- 일반 함수인 경우, 브라우저 상에서 window가 this입니다.
- 이벤트가 발생한 경우, 이벤트를 발생한 객체가 this입니다.