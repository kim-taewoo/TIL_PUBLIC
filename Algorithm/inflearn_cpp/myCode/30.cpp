#include <stdio.h>

int main()
{
    // 12345
    // 뒤에서부터 한 자리씩 3 으로 고정 시켰을 때,
    // 나머지 자리수를 변화시켜서 몇 개를 만들 수 있는지 계산
    // 마지막 자리를 고정시킨다면 앞 4자리를 움직일 수 있다. 
    // 원본 숫자의 자리 숫자가 5이기에 
    // 00003 부터, 12343 까지 모두 가능하다. 즉 1234 + 1(0 일때)인 1235개.
    // 이제 2번째 자리를 고정시켜보면, 00030 부터 12335 까지 가능하다.
    // 이 때 왼쪽과 오른쪽을 구분해서 개수를 세어줄 필요가 있다.
    // 이번에도 원본 자리 숫자가 3보다 큰 4이기 때문에 왼쪽은 000~123까지 124개 가능하다.
    // 그런데 124개 중 하나하나 마다, 오른쪽 자리수 변화를 곱해줘야 한다.
    // 예로, 00030 부터 00039 까지 10개가 가능하다. 
    // 즉 124 * (오른쪽 자리 수) 가 존재한다. 
    // 주의할 점은, 원본 자리 수가 3보다 작거나 같으면 개수가 달라진다.
    // 00300 일 때, 위 방식처럼 13 * 자리 수 해버리면, 마지막 12399 같은 것까지 세는 문제가 생긴다.
    // 따라서 원본 자리 숫자가 3이면 124 가 아닌 123 개까지만 원래 방식대로 곱하고,
    // 왼쪽이 12 인 마지막에는 123xx, 즉 오른쪽에 존재하는 수만큼만 개수를 더해주어야 한다.
    // 마지막으로 원본 자리 숫자가 3보다 작은 경우에는, 
    // 03xxx 부터 왼쪽 숫자가 원본 자리 숫자보다 작은 경우에만 카운트 가능하다.
    // 예를 들어 원본 숫자가 32999 에서 2 의 자리를 생각해보면,
    // 03000~03999, 13000~, 23000~ 만 가능하다. 즉 3일 때 마지막 오른쪽 숫자 계산하는 단계 전까지만 계산한다.
    
    int n;
    scanf("%d", &n);
    // # 0번째 loop
    // 왼쪽에는 10으로 나눈 몫, 
    // 오른쪽에는 1로 나눈 나머지 값인 0.
    // # 1번째 loop
    // 왼쪽에는 100으로 나눈 몫
    // 오른쪽에는 10으로 나눈 나머지값인 일의 자리 수
    // # 마지막 loop
    // 왼쪽은 본래 자리 수보다 더 큰 수로 나눈 몫인 0
    // 오른쪽은 본래 자리 수 만큼의 길이로 나눈 나머지 값
    // 즉 rt 를 기준으로 k 를 1 부터 자리수 크기만큼 증가시키고 
    // lt 는 k * 10 으로 나눈 몫으로 배정
    int lt, rt, curr, k = 1, result = 0;
    do
    {
        rt = n % k;
        lt = n / (k*10);
        // 현재 자리 수는 k 로 나눈 것의 몫을 다시 10 으로 나눈 나머지값
        // 즉 뒤에서부터 한 칸 씩 잘라낸다고 생각하자. 
        curr = (n/k) % 10;

        if (curr == 3) result += ((lt * k) + (rt+1));
        else if (curr > 3) result += ((lt+1) * k);
        else result += lt*k;

        k *= 10;
    } while (lt > 0);
    
    printf("%d", result);

    return 0;
}